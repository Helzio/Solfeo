// coverage:ignore-file
// GENERATED CODE - DO NOT MODIFY BY HAND
// ignore_for_file: type=lint
// ignore_for_file: unused_element, deprecated_member_use, deprecated_member_use_from_same_package, use_function_type_syntax_for_parameters, unnecessary_const, avoid_init_to_null, invalid_override_different_default_values_named, prefer_expression_function_bodies, annotate_overrides, invalid_annotation_target

part of 'pentagrama.dart';

// **************************************************************************
// FreezedGenerator
// **************************************************************************

T _$identity<T>(T value) => value;

final _privateConstructorUsedError = UnsupportedError(
    'It seems like you constructed your class using `MyClass._()`. This constructor is only meant to be used by freezed and you are not supposed to need it nor use it.\nPlease check the documentation here for more informations: https://github.com/rrousselGit/freezed#custom-getters-and-methods');

/// @nodoc
class _$PentagramaTearOff {
  const _$PentagramaTearOff();

  _Pentagrama call(
      {required Clave clave,
      required int numerador,
      required int denominador,
      required List<Compas> compases,
      required Armadura armadura,
      required bool Anacruza,
      required int tempo}) {
    return _Pentagrama(
      clave: clave,
      numerador: numerador,
      denominador: denominador,
      compases: compases,
      armadura: armadura,
      Anacruza: Anacruza,
      tempo: tempo,
    );
  }
}

/// @nodoc
const $Pentagrama = _$PentagramaTearOff();

/// @nodoc
mixin _$Pentagrama {
  Clave get clave => throw _privateConstructorUsedError;
  int get numerador => throw _privateConstructorUsedError;
  int get denominador => throw _privateConstructorUsedError;
  List<Compas> get compases => throw _privateConstructorUsedError;
  Armadura get armadura => throw _privateConstructorUsedError;
  bool get Anacruza => throw _privateConstructorUsedError;
  int get tempo => throw _privateConstructorUsedError;

  @JsonKey(ignore: true)
  $PentagramaCopyWith<Pentagrama> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $PentagramaCopyWith<$Res> {
  factory $PentagramaCopyWith(
          Pentagrama value, $Res Function(Pentagrama) then) =
      _$PentagramaCopyWithImpl<$Res>;
  $Res call(
      {Clave clave,
      int numerador,
      int denominador,
      List<Compas> compases,
      Armadura armadura,
      bool Anacruza,
      int tempo});
}

/// @nodoc
class _$PentagramaCopyWithImpl<$Res> implements $PentagramaCopyWith<$Res> {
  _$PentagramaCopyWithImpl(this._value, this._then);

  final Pentagrama _value;
  // ignore: unused_field
  final $Res Function(Pentagrama) _then;

  @override
  $Res call({
    Object? clave = freezed,
    Object? numerador = freezed,
    Object? denominador = freezed,
    Object? compases = freezed,
    Object? armadura = freezed,
    Object? Anacruza = freezed,
    Object? tempo = freezed,
  }) {
    return _then(_value.copyWith(
      clave: clave == freezed
          ? _value.clave
          : clave // ignore: cast_nullable_to_non_nullable
              as Clave,
      numerador: numerador == freezed
          ? _value.numerador
          : numerador // ignore: cast_nullable_to_non_nullable
              as int,
      denominador: denominador == freezed
          ? _value.denominador
          : denominador // ignore: cast_nullable_to_non_nullable
              as int,
      compases: compases == freezed
          ? _value.compases
          : compases // ignore: cast_nullable_to_non_nullable
              as List<Compas>,
      armadura: armadura == freezed
          ? _value.armadura
          : armadura // ignore: cast_nullable_to_non_nullable
              as Armadura,
      Anacruza: Anacruza == freezed
          ? _value.Anacruza
          : Anacruza // ignore: cast_nullable_to_non_nullable
              as bool,
      tempo: tempo == freezed
          ? _value.tempo
          : tempo // ignore: cast_nullable_to_non_nullable
              as int,
    ));
  }
}

/// @nodoc
abstract class _$PentagramaCopyWith<$Res> implements $PentagramaCopyWith<$Res> {
  factory _$PentagramaCopyWith(
          _Pentagrama value, $Res Function(_Pentagrama) then) =
      __$PentagramaCopyWithImpl<$Res>;
  @override
  $Res call(
      {Clave clave,
      int numerador,
      int denominador,
      List<Compas> compases,
      Armadura armadura,
      bool Anacruza,
      int tempo});
}

/// @nodoc
class __$PentagramaCopyWithImpl<$Res> extends _$PentagramaCopyWithImpl<$Res>
    implements _$PentagramaCopyWith<$Res> {
  __$PentagramaCopyWithImpl(
      _Pentagrama _value, $Res Function(_Pentagrama) _then)
      : super(_value, (v) => _then(v as _Pentagrama));

  @override
  _Pentagrama get _value => super._value as _Pentagrama;

  @override
  $Res call({
    Object? clave = freezed,
    Object? numerador = freezed,
    Object? denominador = freezed,
    Object? compases = freezed,
    Object? armadura = freezed,
    Object? Anacruza = freezed,
    Object? tempo = freezed,
  }) {
    return _then(_Pentagrama(
      clave: clave == freezed
          ? _value.clave
          : clave // ignore: cast_nullable_to_non_nullable
              as Clave,
      numerador: numerador == freezed
          ? _value.numerador
          : numerador // ignore: cast_nullable_to_non_nullable
              as int,
      denominador: denominador == freezed
          ? _value.denominador
          : denominador // ignore: cast_nullable_to_non_nullable
              as int,
      compases: compases == freezed
          ? _value.compases
          : compases // ignore: cast_nullable_to_non_nullable
              as List<Compas>,
      armadura: armadura == freezed
          ? _value.armadura
          : armadura // ignore: cast_nullable_to_non_nullable
              as Armadura,
      Anacruza: Anacruza == freezed
          ? _value.Anacruza
          : Anacruza // ignore: cast_nullable_to_non_nullable
              as bool,
      tempo: tempo == freezed
          ? _value.tempo
          : tempo // ignore: cast_nullable_to_non_nullable
              as int,
    ));
  }
}

/// @nodoc

class _$_Pentagrama extends _Pentagrama {
  const _$_Pentagrama(
      {required this.clave,
      required this.numerador,
      required this.denominador,
      required this.compases,
      required this.armadura,
      required this.Anacruza,
      required this.tempo})
      : super._();

  @override
  final Clave clave;
  @override
  final int numerador;
  @override
  final int denominador;
  @override
  final List<Compas> compases;
  @override
  final Armadura armadura;
  @override
  final bool Anacruza;
  @override
  final int tempo;

  @override
  String toString() {
    return 'Pentagrama(clave: $clave, numerador: $numerador, denominador: $denominador, compases: $compases, armadura: $armadura, Anacruza: $Anacruza, tempo: $tempo)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _Pentagrama &&
            const DeepCollectionEquality().equals(other.clave, clave) &&
            const DeepCollectionEquality().equals(other.numerador, numerador) &&
            const DeepCollectionEquality()
                .equals(other.denominador, denominador) &&
            const DeepCollectionEquality().equals(other.compases, compases) &&
            const DeepCollectionEquality().equals(other.armadura, armadura) &&
            const DeepCollectionEquality().equals(other.Anacruza, Anacruza) &&
            const DeepCollectionEquality().equals(other.tempo, tempo));
  }

  @override
  int get hashCode => Object.hash(
      runtimeType,
      const DeepCollectionEquality().hash(clave),
      const DeepCollectionEquality().hash(numerador),
      const DeepCollectionEquality().hash(denominador),
      const DeepCollectionEquality().hash(compases),
      const DeepCollectionEquality().hash(armadura),
      const DeepCollectionEquality().hash(Anacruza),
      const DeepCollectionEquality().hash(tempo));

  @JsonKey(ignore: true)
  @override
  _$PentagramaCopyWith<_Pentagrama> get copyWith =>
      __$PentagramaCopyWithImpl<_Pentagrama>(this, _$identity);
}

abstract class _Pentagrama extends Pentagrama {
  const factory _Pentagrama(
      {required Clave clave,
      required int numerador,
      required int denominador,
      required List<Compas> compases,
      required Armadura armadura,
      required bool Anacruza,
      required int tempo}) = _$_Pentagrama;
  const _Pentagrama._() : super._();

  @override
  Clave get clave;
  @override
  int get numerador;
  @override
  int get denominador;
  @override
  List<Compas> get compases;
  @override
  Armadura get armadura;
  @override
  bool get Anacruza;
  @override
  int get tempo;
  @override
  @JsonKey(ignore: true)
  _$PentagramaCopyWith<_Pentagrama> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
class _$CompasTearOff {
  const _$CompasTearOff();

  _Compas call(
      {required int numerador,
      required int denominador,
      required List<Nota> notas}) {
    return _Compas(
      numerador: numerador,
      denominador: denominador,
      notas: notas,
    );
  }
}

/// @nodoc
const $Compas = _$CompasTearOff();

/// @nodoc
mixin _$Compas {
  int get numerador => throw _privateConstructorUsedError;
  int get denominador => throw _privateConstructorUsedError;
  List<Nota> get notas => throw _privateConstructorUsedError;

  @JsonKey(ignore: true)
  $CompasCopyWith<Compas> get copyWith => throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $CompasCopyWith<$Res> {
  factory $CompasCopyWith(Compas value, $Res Function(Compas) then) =
      _$CompasCopyWithImpl<$Res>;
  $Res call({int numerador, int denominador, List<Nota> notas});
}

/// @nodoc
class _$CompasCopyWithImpl<$Res> implements $CompasCopyWith<$Res> {
  _$CompasCopyWithImpl(this._value, this._then);

  final Compas _value;
  // ignore: unused_field
  final $Res Function(Compas) _then;

  @override
  $Res call({
    Object? numerador = freezed,
    Object? denominador = freezed,
    Object? notas = freezed,
  }) {
    return _then(_value.copyWith(
      numerador: numerador == freezed
          ? _value.numerador
          : numerador // ignore: cast_nullable_to_non_nullable
              as int,
      denominador: denominador == freezed
          ? _value.denominador
          : denominador // ignore: cast_nullable_to_non_nullable
              as int,
      notas: notas == freezed
          ? _value.notas
          : notas // ignore: cast_nullable_to_non_nullable
              as List<Nota>,
    ));
  }
}

/// @nodoc
abstract class _$CompasCopyWith<$Res> implements $CompasCopyWith<$Res> {
  factory _$CompasCopyWith(_Compas value, $Res Function(_Compas) then) =
      __$CompasCopyWithImpl<$Res>;
  @override
  $Res call({int numerador, int denominador, List<Nota> notas});
}

/// @nodoc
class __$CompasCopyWithImpl<$Res> extends _$CompasCopyWithImpl<$Res>
    implements _$CompasCopyWith<$Res> {
  __$CompasCopyWithImpl(_Compas _value, $Res Function(_Compas) _then)
      : super(_value, (v) => _then(v as _Compas));

  @override
  _Compas get _value => super._value as _Compas;

  @override
  $Res call({
    Object? numerador = freezed,
    Object? denominador = freezed,
    Object? notas = freezed,
  }) {
    return _then(_Compas(
      numerador: numerador == freezed
          ? _value.numerador
          : numerador // ignore: cast_nullable_to_non_nullable
              as int,
      denominador: denominador == freezed
          ? _value.denominador
          : denominador // ignore: cast_nullable_to_non_nullable
              as int,
      notas: notas == freezed
          ? _value.notas
          : notas // ignore: cast_nullable_to_non_nullable
              as List<Nota>,
    ));
  }
}

/// @nodoc

class _$_Compas extends _Compas {
  const _$_Compas(
      {required this.numerador, required this.denominador, required this.notas})
      : super._();

  @override
  final int numerador;
  @override
  final int denominador;
  @override
  final List<Nota> notas;

  @override
  String toString() {
    return 'Compas(numerador: $numerador, denominador: $denominador, notas: $notas)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _Compas &&
            const DeepCollectionEquality().equals(other.numerador, numerador) &&
            const DeepCollectionEquality()
                .equals(other.denominador, denominador) &&
            const DeepCollectionEquality().equals(other.notas, notas));
  }

  @override
  int get hashCode => Object.hash(
      runtimeType,
      const DeepCollectionEquality().hash(numerador),
      const DeepCollectionEquality().hash(denominador),
      const DeepCollectionEquality().hash(notas));

  @JsonKey(ignore: true)
  @override
  _$CompasCopyWith<_Compas> get copyWith =>
      __$CompasCopyWithImpl<_Compas>(this, _$identity);
}

abstract class _Compas extends Compas {
  const factory _Compas(
      {required int numerador,
      required int denominador,
      required List<Nota> notas}) = _$_Compas;
  const _Compas._() : super._();

  @override
  int get numerador;
  @override
  int get denominador;
  @override
  List<Nota> get notas;
  @override
  @JsonKey(ignore: true)
  _$CompasCopyWith<_Compas> get copyWith => throw _privateConstructorUsedError;
}

/// @nodoc
class _$AcordeTearOff {
  const _$AcordeTearOff();

  _Acorde call({required List<Nota> notas}) {
    return _Acorde(
      notas: notas,
    );
  }
}

/// @nodoc
const $Acorde = _$AcordeTearOff();

/// @nodoc
mixin _$Acorde {
  List<Nota> get notas => throw _privateConstructorUsedError;

  @JsonKey(ignore: true)
  $AcordeCopyWith<Acorde> get copyWith => throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $AcordeCopyWith<$Res> {
  factory $AcordeCopyWith(Acorde value, $Res Function(Acorde) then) =
      _$AcordeCopyWithImpl<$Res>;
  $Res call({List<Nota> notas});
}

/// @nodoc
class _$AcordeCopyWithImpl<$Res> implements $AcordeCopyWith<$Res> {
  _$AcordeCopyWithImpl(this._value, this._then);

  final Acorde _value;
  // ignore: unused_field
  final $Res Function(Acorde) _then;

  @override
  $Res call({
    Object? notas = freezed,
  }) {
    return _then(_value.copyWith(
      notas: notas == freezed
          ? _value.notas
          : notas // ignore: cast_nullable_to_non_nullable
              as List<Nota>,
    ));
  }
}

/// @nodoc
abstract class _$AcordeCopyWith<$Res> implements $AcordeCopyWith<$Res> {
  factory _$AcordeCopyWith(_Acorde value, $Res Function(_Acorde) then) =
      __$AcordeCopyWithImpl<$Res>;
  @override
  $Res call({List<Nota> notas});
}

/// @nodoc
class __$AcordeCopyWithImpl<$Res> extends _$AcordeCopyWithImpl<$Res>
    implements _$AcordeCopyWith<$Res> {
  __$AcordeCopyWithImpl(_Acorde _value, $Res Function(_Acorde) _then)
      : super(_value, (v) => _then(v as _Acorde));

  @override
  _Acorde get _value => super._value as _Acorde;

  @override
  $Res call({
    Object? notas = freezed,
  }) {
    return _then(_Acorde(
      notas: notas == freezed
          ? _value.notas
          : notas // ignore: cast_nullable_to_non_nullable
              as List<Nota>,
    ));
  }
}

/// @nodoc

class _$_Acorde extends _Acorde {
  const _$_Acorde({required this.notas}) : super._();

  @override
  final List<Nota> notas;

  @override
  String toString() {
    return 'Acorde(notas: $notas)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _Acorde &&
            const DeepCollectionEquality().equals(other.notas, notas));
  }

  @override
  int get hashCode =>
      Object.hash(runtimeType, const DeepCollectionEquality().hash(notas));

  @JsonKey(ignore: true)
  @override
  _$AcordeCopyWith<_Acorde> get copyWith =>
      __$AcordeCopyWithImpl<_Acorde>(this, _$identity);
}

abstract class _Acorde extends Acorde {
  const factory _Acorde({required List<Nota> notas}) = _$_Acorde;
  const _Acorde._() : super._();

  @override
  List<Nota> get notas;
  @override
  @JsonKey(ignore: true)
  _$AcordeCopyWith<_Acorde> get copyWith => throw _privateConstructorUsedError;
}

/// @nodoc
class _$NotaTearOff {
  const _$NotaTearOff();

  _Nota call(
      {required Tono tono,
      required Ocatava ocatava,
      required Valor valor,
      required bool silencio,
      required PuntillosRepeticion? puntillosRepeticion,
      required int casillaDeRepeticion,
      required bool puntillo,
      required bool calderon}) {
    return _Nota(
      tono: tono,
      ocatava: ocatava,
      valor: valor,
      silencio: silencio,
      puntillosRepeticion: puntillosRepeticion,
      casillaDeRepeticion: casillaDeRepeticion,
      puntillo: puntillo,
      calderon: calderon,
    );
  }
}

/// @nodoc
const $Nota = _$NotaTearOff();

/// @nodoc
mixin _$Nota {
  Tono get tono => throw _privateConstructorUsedError;
  Ocatava get ocatava => throw _privateConstructorUsedError;
  Valor get valor => throw _privateConstructorUsedError;
  bool get silencio => throw _privateConstructorUsedError;
  PuntillosRepeticion? get puntillosRepeticion =>
      throw _privateConstructorUsedError;
  int get casillaDeRepeticion => throw _privateConstructorUsedError;
  bool get puntillo => throw _privateConstructorUsedError;
  bool get calderon => throw _privateConstructorUsedError;

  @JsonKey(ignore: true)
  $NotaCopyWith<Nota> get copyWith => throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $NotaCopyWith<$Res> {
  factory $NotaCopyWith(Nota value, $Res Function(Nota) then) =
      _$NotaCopyWithImpl<$Res>;
  $Res call(
      {Tono tono,
      Ocatava ocatava,
      Valor valor,
      bool silencio,
      PuntillosRepeticion? puntillosRepeticion,
      int casillaDeRepeticion,
      bool puntillo,
      bool calderon});
}

/// @nodoc
class _$NotaCopyWithImpl<$Res> implements $NotaCopyWith<$Res> {
  _$NotaCopyWithImpl(this._value, this._then);

  final Nota _value;
  // ignore: unused_field
  final $Res Function(Nota) _then;

  @override
  $Res call({
    Object? tono = freezed,
    Object? ocatava = freezed,
    Object? valor = freezed,
    Object? silencio = freezed,
    Object? puntillosRepeticion = freezed,
    Object? casillaDeRepeticion = freezed,
    Object? puntillo = freezed,
    Object? calderon = freezed,
  }) {
    return _then(_value.copyWith(
      tono: tono == freezed
          ? _value.tono
          : tono // ignore: cast_nullable_to_non_nullable
              as Tono,
      ocatava: ocatava == freezed
          ? _value.ocatava
          : ocatava // ignore: cast_nullable_to_non_nullable
              as Ocatava,
      valor: valor == freezed
          ? _value.valor
          : valor // ignore: cast_nullable_to_non_nullable
              as Valor,
      silencio: silencio == freezed
          ? _value.silencio
          : silencio // ignore: cast_nullable_to_non_nullable
              as bool,
      puntillosRepeticion: puntillosRepeticion == freezed
          ? _value.puntillosRepeticion
          : puntillosRepeticion // ignore: cast_nullable_to_non_nullable
              as PuntillosRepeticion?,
      casillaDeRepeticion: casillaDeRepeticion == freezed
          ? _value.casillaDeRepeticion
          : casillaDeRepeticion // ignore: cast_nullable_to_non_nullable
              as int,
      puntillo: puntillo == freezed
          ? _value.puntillo
          : puntillo // ignore: cast_nullable_to_non_nullable
              as bool,
      calderon: calderon == freezed
          ? _value.calderon
          : calderon // ignore: cast_nullable_to_non_nullable
              as bool,
    ));
  }
}

/// @nodoc
abstract class _$NotaCopyWith<$Res> implements $NotaCopyWith<$Res> {
  factory _$NotaCopyWith(_Nota value, $Res Function(_Nota) then) =
      __$NotaCopyWithImpl<$Res>;
  @override
  $Res call(
      {Tono tono,
      Ocatava ocatava,
      Valor valor,
      bool silencio,
      PuntillosRepeticion? puntillosRepeticion,
      int casillaDeRepeticion,
      bool puntillo,
      bool calderon});
}

/// @nodoc
class __$NotaCopyWithImpl<$Res> extends _$NotaCopyWithImpl<$Res>
    implements _$NotaCopyWith<$Res> {
  __$NotaCopyWithImpl(_Nota _value, $Res Function(_Nota) _then)
      : super(_value, (v) => _then(v as _Nota));

  @override
  _Nota get _value => super._value as _Nota;

  @override
  $Res call({
    Object? tono = freezed,
    Object? ocatava = freezed,
    Object? valor = freezed,
    Object? silencio = freezed,
    Object? puntillosRepeticion = freezed,
    Object? casillaDeRepeticion = freezed,
    Object? puntillo = freezed,
    Object? calderon = freezed,
  }) {
    return _then(_Nota(
      tono: tono == freezed
          ? _value.tono
          : tono // ignore: cast_nullable_to_non_nullable
              as Tono,
      ocatava: ocatava == freezed
          ? _value.ocatava
          : ocatava // ignore: cast_nullable_to_non_nullable
              as Ocatava,
      valor: valor == freezed
          ? _value.valor
          : valor // ignore: cast_nullable_to_non_nullable
              as Valor,
      silencio: silencio == freezed
          ? _value.silencio
          : silencio // ignore: cast_nullable_to_non_nullable
              as bool,
      puntillosRepeticion: puntillosRepeticion == freezed
          ? _value.puntillosRepeticion
          : puntillosRepeticion // ignore: cast_nullable_to_non_nullable
              as PuntillosRepeticion?,
      casillaDeRepeticion: casillaDeRepeticion == freezed
          ? _value.casillaDeRepeticion
          : casillaDeRepeticion // ignore: cast_nullable_to_non_nullable
              as int,
      puntillo: puntillo == freezed
          ? _value.puntillo
          : puntillo // ignore: cast_nullable_to_non_nullable
              as bool,
      calderon: calderon == freezed
          ? _value.calderon
          : calderon // ignore: cast_nullable_to_non_nullable
              as bool,
    ));
  }
}

/// @nodoc

class _$_Nota extends _Nota {
  const _$_Nota(
      {required this.tono,
      required this.ocatava,
      required this.valor,
      required this.silencio,
      required this.puntillosRepeticion,
      required this.casillaDeRepeticion,
      required this.puntillo,
      required this.calderon})
      : super._();

  @override
  final Tono tono;
  @override
  final Ocatava ocatava;
  @override
  final Valor valor;
  @override
  final bool silencio;
  @override
  final PuntillosRepeticion? puntillosRepeticion;
  @override
  final int casillaDeRepeticion;
  @override
  final bool puntillo;
  @override
  final bool calderon;

  @override
  String toString() {
    return 'Nota(tono: $tono, ocatava: $ocatava, valor: $valor, silencio: $silencio, puntillosRepeticion: $puntillosRepeticion, casillaDeRepeticion: $casillaDeRepeticion, puntillo: $puntillo, calderon: $calderon)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _Nota &&
            const DeepCollectionEquality().equals(other.tono, tono) &&
            const DeepCollectionEquality().equals(other.ocatava, ocatava) &&
            const DeepCollectionEquality().equals(other.valor, valor) &&
            const DeepCollectionEquality().equals(other.silencio, silencio) &&
            const DeepCollectionEquality()
                .equals(other.puntillosRepeticion, puntillosRepeticion) &&
            const DeepCollectionEquality()
                .equals(other.casillaDeRepeticion, casillaDeRepeticion) &&
            const DeepCollectionEquality().equals(other.puntillo, puntillo) &&
            const DeepCollectionEquality().equals(other.calderon, calderon));
  }

  @override
  int get hashCode => Object.hash(
      runtimeType,
      const DeepCollectionEquality().hash(tono),
      const DeepCollectionEquality().hash(ocatava),
      const DeepCollectionEquality().hash(valor),
      const DeepCollectionEquality().hash(silencio),
      const DeepCollectionEquality().hash(puntillosRepeticion),
      const DeepCollectionEquality().hash(casillaDeRepeticion),
      const DeepCollectionEquality().hash(puntillo),
      const DeepCollectionEquality().hash(calderon));

  @JsonKey(ignore: true)
  @override
  _$NotaCopyWith<_Nota> get copyWith =>
      __$NotaCopyWithImpl<_Nota>(this, _$identity);
}

abstract class _Nota extends Nota {
  const factory _Nota(
      {required Tono tono,
      required Ocatava ocatava,
      required Valor valor,
      required bool silencio,
      required PuntillosRepeticion? puntillosRepeticion,
      required int casillaDeRepeticion,
      required bool puntillo,
      required bool calderon}) = _$_Nota;
  const _Nota._() : super._();

  @override
  Tono get tono;
  @override
  Ocatava get ocatava;
  @override
  Valor get valor;
  @override
  bool get silencio;
  @override
  PuntillosRepeticion? get puntillosRepeticion;
  @override
  int get casillaDeRepeticion;
  @override
  bool get puntillo;
  @override
  bool get calderon;
  @override
  @JsonKey(ignore: true)
  _$NotaCopyWith<_Nota> get copyWith => throw _privateConstructorUsedError;
}
