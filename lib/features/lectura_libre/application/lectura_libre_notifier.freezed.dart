// coverage:ignore-file
// GENERATED CODE - DO NOT MODIFY BY HAND
// ignore_for_file: type=lint
// ignore_for_file: unused_element, deprecated_member_use, deprecated_member_use_from_same_package, use_function_type_syntax_for_parameters, unnecessary_const, avoid_init_to_null, invalid_override_different_default_values_named, prefer_expression_function_bodies, annotate_overrides, invalid_annotation_target

part of 'lectura_libre_notifier.dart';

// **************************************************************************
// FreezedGenerator
// **************************************************************************

T _$identity<T>(T value) => value;

final _privateConstructorUsedError = UnsupportedError(
    'It seems like you constructed your class using `MyClass._()`. This constructor is only meant to be used by freezed and you are not supposed to need it nor use it.\nPlease check the documentation here for more informations: https://github.com/rrousselGit/freezed#custom-getters-and-methods');

/// @nodoc
class _$LecturaLibreStateTearOff {
  const _$LecturaLibreStateTearOff();

  _LecturaLibreState call(
      {required int index,
      required int level,
      required double speed,
      required double lastSpeed,
      required double accuracy,
      required double lastAccuracy,
      required double score,
      required double lastScore,
      required String enterNote,
      required List<String> availableNotes,
      required List<String> currentNotes,
      required Map<String, int> errors,
      required int errorCount,
      required List<int> listErrorIndex,
      required bool isRunning,
      required List<String> notes,
      required DateTime? startTime,
      required DateTime? endTime}) {
    return _LecturaLibreState(
      index: index,
      level: level,
      speed: speed,
      lastSpeed: lastSpeed,
      accuracy: accuracy,
      lastAccuracy: lastAccuracy,
      score: score,
      lastScore: lastScore,
      enterNote: enterNote,
      availableNotes: availableNotes,
      currentNotes: currentNotes,
      errors: errors,
      errorCount: errorCount,
      listErrorIndex: listErrorIndex,
      isRunning: isRunning,
      notes: notes,
      startTime: startTime,
      endTime: endTime,
    );
  }
}

/// @nodoc
const $LecturaLibreState = _$LecturaLibreStateTearOff();

/// @nodoc
mixin _$LecturaLibreState {
  int get index => throw _privateConstructorUsedError;
  int get level => throw _privateConstructorUsedError;
  double get speed => throw _privateConstructorUsedError;
  double get lastSpeed => throw _privateConstructorUsedError;
  double get accuracy => throw _privateConstructorUsedError;
  double get lastAccuracy => throw _privateConstructorUsedError;
  double get score => throw _privateConstructorUsedError;
  double get lastScore => throw _privateConstructorUsedError;
  String get enterNote => throw _privateConstructorUsedError;
  List<String> get availableNotes => throw _privateConstructorUsedError;
  List<String> get currentNotes => throw _privateConstructorUsedError;
  Map<String, int> get errors => throw _privateConstructorUsedError;
  int get errorCount => throw _privateConstructorUsedError;
  List<int> get listErrorIndex => throw _privateConstructorUsedError;
  bool get isRunning => throw _privateConstructorUsedError;
  List<String> get notes => throw _privateConstructorUsedError;
  DateTime? get startTime => throw _privateConstructorUsedError;
  DateTime? get endTime => throw _privateConstructorUsedError;

  @JsonKey(ignore: true)
  $LecturaLibreStateCopyWith<LecturaLibreState> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $LecturaLibreStateCopyWith<$Res> {
  factory $LecturaLibreStateCopyWith(
          LecturaLibreState value, $Res Function(LecturaLibreState) then) =
      _$LecturaLibreStateCopyWithImpl<$Res>;
  $Res call(
      {int index,
      int level,
      double speed,
      double lastSpeed,
      double accuracy,
      double lastAccuracy,
      double score,
      double lastScore,
      String enterNote,
      List<String> availableNotes,
      List<String> currentNotes,
      Map<String, int> errors,
      int errorCount,
      List<int> listErrorIndex,
      bool isRunning,
      List<String> notes,
      DateTime? startTime,
      DateTime? endTime});
}

/// @nodoc
class _$LecturaLibreStateCopyWithImpl<$Res>
    implements $LecturaLibreStateCopyWith<$Res> {
  _$LecturaLibreStateCopyWithImpl(this._value, this._then);

  final LecturaLibreState _value;
  // ignore: unused_field
  final $Res Function(LecturaLibreState) _then;

  @override
  $Res call({
    Object? index = freezed,
    Object? level = freezed,
    Object? speed = freezed,
    Object? lastSpeed = freezed,
    Object? accuracy = freezed,
    Object? lastAccuracy = freezed,
    Object? score = freezed,
    Object? lastScore = freezed,
    Object? enterNote = freezed,
    Object? availableNotes = freezed,
    Object? currentNotes = freezed,
    Object? errors = freezed,
    Object? errorCount = freezed,
    Object? listErrorIndex = freezed,
    Object? isRunning = freezed,
    Object? notes = freezed,
    Object? startTime = freezed,
    Object? endTime = freezed,
  }) {
    return _then(_value.copyWith(
      index: index == freezed
          ? _value.index
          : index // ignore: cast_nullable_to_non_nullable
              as int,
      level: level == freezed
          ? _value.level
          : level // ignore: cast_nullable_to_non_nullable
              as int,
      speed: speed == freezed
          ? _value.speed
          : speed // ignore: cast_nullable_to_non_nullable
              as double,
      lastSpeed: lastSpeed == freezed
          ? _value.lastSpeed
          : lastSpeed // ignore: cast_nullable_to_non_nullable
              as double,
      accuracy: accuracy == freezed
          ? _value.accuracy
          : accuracy // ignore: cast_nullable_to_non_nullable
              as double,
      lastAccuracy: lastAccuracy == freezed
          ? _value.lastAccuracy
          : lastAccuracy // ignore: cast_nullable_to_non_nullable
              as double,
      score: score == freezed
          ? _value.score
          : score // ignore: cast_nullable_to_non_nullable
              as double,
      lastScore: lastScore == freezed
          ? _value.lastScore
          : lastScore // ignore: cast_nullable_to_non_nullable
              as double,
      enterNote: enterNote == freezed
          ? _value.enterNote
          : enterNote // ignore: cast_nullable_to_non_nullable
              as String,
      availableNotes: availableNotes == freezed
          ? _value.availableNotes
          : availableNotes // ignore: cast_nullable_to_non_nullable
              as List<String>,
      currentNotes: currentNotes == freezed
          ? _value.currentNotes
          : currentNotes // ignore: cast_nullable_to_non_nullable
              as List<String>,
      errors: errors == freezed
          ? _value.errors
          : errors // ignore: cast_nullable_to_non_nullable
              as Map<String, int>,
      errorCount: errorCount == freezed
          ? _value.errorCount
          : errorCount // ignore: cast_nullable_to_non_nullable
              as int,
      listErrorIndex: listErrorIndex == freezed
          ? _value.listErrorIndex
          : listErrorIndex // ignore: cast_nullable_to_non_nullable
              as List<int>,
      isRunning: isRunning == freezed
          ? _value.isRunning
          : isRunning // ignore: cast_nullable_to_non_nullable
              as bool,
      notes: notes == freezed
          ? _value.notes
          : notes // ignore: cast_nullable_to_non_nullable
              as List<String>,
      startTime: startTime == freezed
          ? _value.startTime
          : startTime // ignore: cast_nullable_to_non_nullable
              as DateTime?,
      endTime: endTime == freezed
          ? _value.endTime
          : endTime // ignore: cast_nullable_to_non_nullable
              as DateTime?,
    ));
  }
}

/// @nodoc
abstract class _$LecturaLibreStateCopyWith<$Res>
    implements $LecturaLibreStateCopyWith<$Res> {
  factory _$LecturaLibreStateCopyWith(
          _LecturaLibreState value, $Res Function(_LecturaLibreState) then) =
      __$LecturaLibreStateCopyWithImpl<$Res>;
  @override
  $Res call(
      {int index,
      int level,
      double speed,
      double lastSpeed,
      double accuracy,
      double lastAccuracy,
      double score,
      double lastScore,
      String enterNote,
      List<String> availableNotes,
      List<String> currentNotes,
      Map<String, int> errors,
      int errorCount,
      List<int> listErrorIndex,
      bool isRunning,
      List<String> notes,
      DateTime? startTime,
      DateTime? endTime});
}

/// @nodoc
class __$LecturaLibreStateCopyWithImpl<$Res>
    extends _$LecturaLibreStateCopyWithImpl<$Res>
    implements _$LecturaLibreStateCopyWith<$Res> {
  __$LecturaLibreStateCopyWithImpl(
      _LecturaLibreState _value, $Res Function(_LecturaLibreState) _then)
      : super(_value, (v) => _then(v as _LecturaLibreState));

  @override
  _LecturaLibreState get _value => super._value as _LecturaLibreState;

  @override
  $Res call({
    Object? index = freezed,
    Object? level = freezed,
    Object? speed = freezed,
    Object? lastSpeed = freezed,
    Object? accuracy = freezed,
    Object? lastAccuracy = freezed,
    Object? score = freezed,
    Object? lastScore = freezed,
    Object? enterNote = freezed,
    Object? availableNotes = freezed,
    Object? currentNotes = freezed,
    Object? errors = freezed,
    Object? errorCount = freezed,
    Object? listErrorIndex = freezed,
    Object? isRunning = freezed,
    Object? notes = freezed,
    Object? startTime = freezed,
    Object? endTime = freezed,
  }) {
    return _then(_LecturaLibreState(
      index: index == freezed
          ? _value.index
          : index // ignore: cast_nullable_to_non_nullable
              as int,
      level: level == freezed
          ? _value.level
          : level // ignore: cast_nullable_to_non_nullable
              as int,
      speed: speed == freezed
          ? _value.speed
          : speed // ignore: cast_nullable_to_non_nullable
              as double,
      lastSpeed: lastSpeed == freezed
          ? _value.lastSpeed
          : lastSpeed // ignore: cast_nullable_to_non_nullable
              as double,
      accuracy: accuracy == freezed
          ? _value.accuracy
          : accuracy // ignore: cast_nullable_to_non_nullable
              as double,
      lastAccuracy: lastAccuracy == freezed
          ? _value.lastAccuracy
          : lastAccuracy // ignore: cast_nullable_to_non_nullable
              as double,
      score: score == freezed
          ? _value.score
          : score // ignore: cast_nullable_to_non_nullable
              as double,
      lastScore: lastScore == freezed
          ? _value.lastScore
          : lastScore // ignore: cast_nullable_to_non_nullable
              as double,
      enterNote: enterNote == freezed
          ? _value.enterNote
          : enterNote // ignore: cast_nullable_to_non_nullable
              as String,
      availableNotes: availableNotes == freezed
          ? _value.availableNotes
          : availableNotes // ignore: cast_nullable_to_non_nullable
              as List<String>,
      currentNotes: currentNotes == freezed
          ? _value.currentNotes
          : currentNotes // ignore: cast_nullable_to_non_nullable
              as List<String>,
      errors: errors == freezed
          ? _value.errors
          : errors // ignore: cast_nullable_to_non_nullable
              as Map<String, int>,
      errorCount: errorCount == freezed
          ? _value.errorCount
          : errorCount // ignore: cast_nullable_to_non_nullable
              as int,
      listErrorIndex: listErrorIndex == freezed
          ? _value.listErrorIndex
          : listErrorIndex // ignore: cast_nullable_to_non_nullable
              as List<int>,
      isRunning: isRunning == freezed
          ? _value.isRunning
          : isRunning // ignore: cast_nullable_to_non_nullable
              as bool,
      notes: notes == freezed
          ? _value.notes
          : notes // ignore: cast_nullable_to_non_nullable
              as List<String>,
      startTime: startTime == freezed
          ? _value.startTime
          : startTime // ignore: cast_nullable_to_non_nullable
              as DateTime?,
      endTime: endTime == freezed
          ? _value.endTime
          : endTime // ignore: cast_nullable_to_non_nullable
              as DateTime?,
    ));
  }
}

/// @nodoc

class _$_LecturaLibreState extends _LecturaLibreState {
  const _$_LecturaLibreState(
      {required this.index,
      required this.level,
      required this.speed,
      required this.lastSpeed,
      required this.accuracy,
      required this.lastAccuracy,
      required this.score,
      required this.lastScore,
      required this.enterNote,
      required this.availableNotes,
      required this.currentNotes,
      required this.errors,
      required this.errorCount,
      required this.listErrorIndex,
      required this.isRunning,
      required this.notes,
      required this.startTime,
      required this.endTime})
      : super._();

  @override
  final int index;
  @override
  final int level;
  @override
  final double speed;
  @override
  final double lastSpeed;
  @override
  final double accuracy;
  @override
  final double lastAccuracy;
  @override
  final double score;
  @override
  final double lastScore;
  @override
  final String enterNote;
  @override
  final List<String> availableNotes;
  @override
  final List<String> currentNotes;
  @override
  final Map<String, int> errors;
  @override
  final int errorCount;
  @override
  final List<int> listErrorIndex;
  @override
  final bool isRunning;
  @override
  final List<String> notes;
  @override
  final DateTime? startTime;
  @override
  final DateTime? endTime;

  @override
  String toString() {
    return 'LecturaLibreState(index: $index, level: $level, speed: $speed, lastSpeed: $lastSpeed, accuracy: $accuracy, lastAccuracy: $lastAccuracy, score: $score, lastScore: $lastScore, enterNote: $enterNote, availableNotes: $availableNotes, currentNotes: $currentNotes, errors: $errors, errorCount: $errorCount, listErrorIndex: $listErrorIndex, isRunning: $isRunning, notes: $notes, startTime: $startTime, endTime: $endTime)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _LecturaLibreState &&
            const DeepCollectionEquality().equals(other.index, index) &&
            const DeepCollectionEquality().equals(other.level, level) &&
            const DeepCollectionEquality().equals(other.speed, speed) &&
            const DeepCollectionEquality().equals(other.lastSpeed, lastSpeed) &&
            const DeepCollectionEquality().equals(other.accuracy, accuracy) &&
            const DeepCollectionEquality()
                .equals(other.lastAccuracy, lastAccuracy) &&
            const DeepCollectionEquality().equals(other.score, score) &&
            const DeepCollectionEquality().equals(other.lastScore, lastScore) &&
            const DeepCollectionEquality().equals(other.enterNote, enterNote) &&
            const DeepCollectionEquality()
                .equals(other.availableNotes, availableNotes) &&
            const DeepCollectionEquality()
                .equals(other.currentNotes, currentNotes) &&
            const DeepCollectionEquality().equals(other.errors, errors) &&
            const DeepCollectionEquality()
                .equals(other.errorCount, errorCount) &&
            const DeepCollectionEquality()
                .equals(other.listErrorIndex, listErrorIndex) &&
            const DeepCollectionEquality().equals(other.isRunning, isRunning) &&
            const DeepCollectionEquality().equals(other.notes, notes) &&
            const DeepCollectionEquality().equals(other.startTime, startTime) &&
            const DeepCollectionEquality().equals(other.endTime, endTime));
  }

  @override
  int get hashCode => Object.hash(
      runtimeType,
      const DeepCollectionEquality().hash(index),
      const DeepCollectionEquality().hash(level),
      const DeepCollectionEquality().hash(speed),
      const DeepCollectionEquality().hash(lastSpeed),
      const DeepCollectionEquality().hash(accuracy),
      const DeepCollectionEquality().hash(lastAccuracy),
      const DeepCollectionEquality().hash(score),
      const DeepCollectionEquality().hash(lastScore),
      const DeepCollectionEquality().hash(enterNote),
      const DeepCollectionEquality().hash(availableNotes),
      const DeepCollectionEquality().hash(currentNotes),
      const DeepCollectionEquality().hash(errors),
      const DeepCollectionEquality().hash(errorCount),
      const DeepCollectionEquality().hash(listErrorIndex),
      const DeepCollectionEquality().hash(isRunning),
      const DeepCollectionEquality().hash(notes),
      const DeepCollectionEquality().hash(startTime),
      const DeepCollectionEquality().hash(endTime));

  @JsonKey(ignore: true)
  @override
  _$LecturaLibreStateCopyWith<_LecturaLibreState> get copyWith =>
      __$LecturaLibreStateCopyWithImpl<_LecturaLibreState>(this, _$identity);
}

abstract class _LecturaLibreState extends LecturaLibreState {
  const factory _LecturaLibreState(
      {required int index,
      required int level,
      required double speed,
      required double lastSpeed,
      required double accuracy,
      required double lastAccuracy,
      required double score,
      required double lastScore,
      required String enterNote,
      required List<String> availableNotes,
      required List<String> currentNotes,
      required Map<String, int> errors,
      required int errorCount,
      required List<int> listErrorIndex,
      required bool isRunning,
      required List<String> notes,
      required DateTime? startTime,
      required DateTime? endTime}) = _$_LecturaLibreState;
  const _LecturaLibreState._() : super._();

  @override
  int get index;
  @override
  int get level;
  @override
  double get speed;
  @override
  double get lastSpeed;
  @override
  double get accuracy;
  @override
  double get lastAccuracy;
  @override
  double get score;
  @override
  double get lastScore;
  @override
  String get enterNote;
  @override
  List<String> get availableNotes;
  @override
  List<String> get currentNotes;
  @override
  Map<String, int> get errors;
  @override
  int get errorCount;
  @override
  List<int> get listErrorIndex;
  @override
  bool get isRunning;
  @override
  List<String> get notes;
  @override
  DateTime? get startTime;
  @override
  DateTime? get endTime;
  @override
  @JsonKey(ignore: true)
  _$LecturaLibreStateCopyWith<_LecturaLibreState> get copyWith =>
      throw _privateConstructorUsedError;
}
